% An implementation of Cannon's algorithm for matrix multiplication.
% Notation: 
%  - (i, j) denotes (row, col)
%  - A, B, C and N*N matrices
%  - Matrices are distributed with submatrices of size (N/R)^2

val N is 4; % Dimension of square matrix
val R is 2; % Num partitions per dimension
val X is R*R;
val MATRIX_STORAGE is (N/R)*(N/R);

proc send_submatrix(chanend c, var M[MATRIX_STORAGE]) is
{ var i;
  for i in [0 for MATRIX_STORAGE] do c ! M[i]
}

proc recv_submatrix(chanend c, var M[MATRIX_STORAGE]) is
{ var i;
  for i in [0 for MATRIX_STORAGE] do c ? M[i]
}

proc cell(val i, val j, chanend n, chanend s, chanend e, chanend w) is
{ var A[];
  var B[];
  var C[];
  var k;

  memalloc(A, MATRIX_STORAGE);
  memalloc(B, MATRIX_STORAGE);
  memalloc(C, MATRIX_STORAGE);
  
  % Circularly shift west each matrix A_{i,j} by i columns
  for k in [0 for i] do
    if j = 0
    then
    { send_submatrix(w, A);
      recv_submatrix(e, A)
    }
    else
    { recv_submatrix(e, A);
      send_submatrix(w, A)
    }

  % Circularly shift north each matrix B_{i,j} by j rows
  for k in [0 for j] do
    if i = 0
    then
    { send_submatrix(s, B);
      recv_submatrix(n, B)
    }
    else
    { recv_submatrix(n, B);
      send_submatrix(s, B)
    };
  
  % Compute C_{i,j}=A_{i,j}*B_{i,j}+C_{,j},
  % circularly shift left A_{i,j} and north B_{i,j} by one.
  for k in [0 for R] do
    if (i = 0) and (j = 0)
    then
    { muladd(); % C = C + A*B
      send_submatrix(s, A);
      send_submatrix(e, B);
      recv_submatrix(n, A);
      recv_submatrix(w, B)
    }
    else if i = 0
    then
    { muladd(); % C = C + A*B
      send_submatrix(s, A);
      recv_submatrix(n, A);
      recv_submatrix(w, B);
      send_submatrix(s, B)
    }
    else if j = 0
    then
    { muladd(); % C = C + A*B
      send_submatrix(e, B);
      recv_submatrix(w, B);
      recv_submatrix(n, A);
      send_submatrix(s, A)
    }
    else
    { muladd(); % C = C + A*B
      recv_submatrix(n, A);
      recv_submatrix(w, B);
      send_submatrix(s, A);
      send_submatrix(e, B)
    };

  memfree(A);
  memfree(B);
  memfree(C)
}

proc main() is
{ chan x[X];
  chan y[X];
  var i;
  var j;
  par i in [0 for R], j in [0 for R] do
    cell(i, j, y[(j*R)+i], y[(j*R)+((i+1) rem R)], 
                 x[(i*R)+j], x[(i*R)+((j+1) rem R)])
}

