val LENGTH is 1000;
val STORAGE is 100;
val N is LENGTH/STORAGE;
val READ is 0;
val WRITE is 1;

proc leaf(chanend c) is
{ var base;
  var data[STORAGE];
  var query;
  var i;
  var v;
  
  % Ignore configuration messages
  c ? v;
  c ? base;
  c ? v;

  % Run
  %while true do
  { c ? query;
    if query = READ
    then
    { c ? i;
      c ? data[i-base] % should be !
    }
    else
    { c ? i;
      c ? v;
      data[i-base] := v
    }
  };
  skip
}

proc branch(chanend root, chanend left, chanend right) is
{ var depth;
  var base;
  var interval;
  var query;
  var i;
  var v;
 
  % Configure
  root ? depth;
  root ? base;
  root ? interval;
  left  ! depth + 1;
  right ! depth + 1;
  left  ! base;
  right ! base + (interval/2);
  left  ! interval/2;
  right ! interval/2;

  % Run
  while true do
  { root ? query;
    if query = READ
    then 
    { root ? i;
      if i < base+(interval/2)
      then
      { left ! READ;
        left ! i;
        left ? v
      }
      else
      { right ! READ;
        right ! i;
        right ? v
      }
    }
    else
    { root  ? i;
      root  ? v;
      if i < base+(interval/2)
      then
      { left ! READ;
        left ! i;
        left ! v
      }
      else
      { right ! READ;
        right ! i;
        right ! v
      }
    }
  }
}

proc serve(chanend c, chanend root) is
{ var query;
  var i;
  var v;
  
  % Configure the structure
  root ! 0;
  root ! 0;
  root ! LENGTH;
  
  % Run
  while true do
  { c ? query;
    if query = READ
    then 
    { c ? i;
      root ! READ;
      root ! i;
      root ? v;
      c ! v
    }
    else 
    { c ? i;
      c ? v;
      root ! WRITE;
      root ! i;
      root ! v
    }
  }
}

proc array(chanend cin) is
{ chan c[(2*N)-1];
  var i;
  server() 
    par i in [0 for N] do 
      leaf(c[(N-1)+i])
  { serve(cin, c[0]) ||
    par i in [0 for N-1] do
      branch(c[i], c[(2*i)+1], c[(2*i)+2])
  }
}

proc read(chanend c, val i, var v) is
{ c ! READ;
  c ! i;
  c ? v
}

proc write(chanend c, val i, val v) is
{ c ! WRITE;
  c ! i;
  c ! v
}

proc bubblesort(chanend c, val n) is
{ var i;
  var j;
  var tmp1;
  var tmp2;
  for i in [0 for n] do
    for j in [0 for n-i-1] do
    { read(c, j, tmp1);
      read(c, j+1, tmp2);
      if tmp1 > tmp2 then 
      { write(c, j, tmp2);
        write(c, j+1, tmp1)
      }
      else skip
    }
}

proc initialise(chanend w) is
{ var i;
  for i in [0 for LENGTH] do
    write(w, i, LENGTH-(i+1))
}
  
proc dump(chanend r) is
{ var i;
  var v;
  for i in [0 for LENGTH] do
  { read(r, i, v);
    printvalln(v)
  }
}

proc main() is
{ server(chan c)
    array(c)
  { initialise(c);
    dump(c);
    bubblesort(c, LENGTH);
    dump(c)
  }
}

