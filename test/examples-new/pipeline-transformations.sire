val N := 10;

proc main() is
  chan c[N+1];
  var i;
  var v;
  { { c[0] ! 0
    ; c[N] ? v
    }
  || par i in [0 for N] do
    { c[i-1] ? v
    ; c[i] ! v + 1
    }
  }

% Add connections and base value

proc main() is
  chan c[N+1];
  var i;
  var v;
  var _b;
{ _b := procid()
; { { connect c[0] to core[f(_b)]
    ; connect c[N]
    ; { c[0] ! 0
      ; c[N] ? v
      }
    }
  || par i in [1 for N] do
    { connect c[i-1]
    ; connect c[i] to core[f(_b)]
    ; { c[i-1] ? v
      ; c[i] ! v + 1
      }
    }
  }
}

% Rename connections

proc main() is
  var i;
  var v;
  chanend c1;
  chanend c2;
  chanend c3;
  chanend c4;
  { { connect c1 to core[x]
    ; connect c2
    ; { c1 ! 0
      ; c2 ? v
      }
    }
  || par i in [0 for N] do
    { connect c3
    ; connect c4 to core[x]
    ; { c3 ? v
      ; c4 ! v + 1
      }
    }
  }

% Expand connections?

proc main() is
  var i;
  var v;
  chanend c1;
  chanend c2;
  chanend c3;
  chanend c4;
  { { connect c1 to procid()
    ; connect c2
    ; { c1 ! 0
      ; c2 ? v
      }
    }
  || par i in [0 for N] do
    { connect c3
    ; if i = 0 then connect c4 to procid()
      else if (i > 1) and (i < N)
      then connect c4 to procid()+1
      else connect c4 to procid()
    ; { c3 ? v
      ; c4 ! v + 1
      }
    }
  }

% Transform parallel composition

proc p1() is
  var v;
  chanend c1;
  chanend c2;
{ connect c1 to core[x]
; connect c2
; { c1 ! 0
  ; c2 ? v
  }
}

proc p2() is
  var v;
  var i;
  chanend c3;
  chanend c4;
  par i in [0 for N] do
  { connect c3
  ; connect c4 to core[x]
  ; { c3 ? v
    ; c4 ! v + 1
    }
  }

proc main() is
  var i;
  var v;
  chanend c1;
  chanend c2;
  chanend c3;
  chanend c4;
  { 
    p1() ||
    p2()
  }

% Transform parallel replication

