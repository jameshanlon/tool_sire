val N = 3;

% North row: source x values
proc produce_xj(val j, chanend south) is
  while true do south ! ANY

% West column: sink y values
proc consume_yi(val i, chanend east) is
  while true do east ? ANY

% East column: source k offsets
proc offset(val ki, chanend west) is
  while true do west ! ki

proc multiplier(val aij, chanend north, chanend south, 
    chanend west, chanend east) is
  var xj;
  var yi; % responsible for a values
{ north ? xj
; while true do
  { south ! xj
  ; east ? yi
  ; west ! yi + (aij * xj)
  ; north ? xj
  }
}

proc sink(chanend north) is
% south row
  while true do                           
  % sink for unused outputs
    north ? ANY

proc main() is
  var a[N*N];
  var k[N];
  var i;
  var j;
  chan north_south[N*(N+1)];
  chan east_west[N*(N+1)];
{
  % initialize a and k
  skip
  
; { par j in [0 for N] do produce_xj(j, north_south[j]) ||
    par i in [0 for N] do offset(k[i], east_west[(N*N) + i]) ||
    par i in [0 for N], j in [0 for N] do 
        multiplier(a[(n * i) + j],
          north_south[(N*i) + j], north_south[(N * (i+1)) + j],
          east_west[i + (N*j)], east_west[i + (N * (j+1))]) ||
    par j in [0 for N] do sink(north_south[(N*N) + j]) ||
    par i in [0 for N] do consume_yi(i, east_west[i])
  }
}

