val N := 8

%proc try(val i) is
%  initialise selection of positions for ith queen
%  while successful or no more positions do
%    if safe then
%      set-queen
%      if i < 8 then
%      { try(i+1)
%      ; if not successful
%        then remove queen
%        else skip
%      }
%      else skip
%   else skip
%
%set-queen:
%    x[i]:=j
%    a[j]:=false
%    b[i+j]:=false
%    c[i-j]:=false
%
%remove-queen:
%    a[j]:=true
%    b[i+j]:=true
%    c[i-j]:=true
%
%safe:
%    a[j] and b[i+j] and c[i-j]

% Try queen i in position j
proc try(val i, var x[N], var a[N], var b[2*N], var c[2*N], var succ) is
{ j := 1
; while ~succ or j<N do
  { succ := false
    % safe
  ; if a[j] and b[i+j] and c[i-j+N] then
      % set-queen
      x[i] := j ; a[j] := false ; b[i+j] := false ; c[i-j+N] := false
      if i < N then
      { try(i+1, x, a, b, c, succ)
      ; if ~succ
        % remove-queen
        then a[j] := true ; b[i+j] := true ; c[i-j+N] := true
        else skip
      }
      else succ = true 
    else skip
  ; j := j + 1
  }
}

proc main() is
  var x[N];
  var a[N];
  var b[2*N];
  var c[2*N];
  var succ;
  var i;
{ for i:=0 to N-1 do a[i] := true
; for i:=0 to 2*N-1 do b[i] := true
; for i:=0 to 2*N-1 do c[i] := true
; try(0, x, a, b, c, succ)
; if succ then 
    for i:=0 to N-1 do printval(x[i])
  else skip
; println()
}
