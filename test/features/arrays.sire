val N := 100;

% Sum an array
func sum(val a[n], val n) is
  var r;
  var i;
{ r := 0
; for i:=1 to n do r := r + a[i]
; return r
}

% Pairwise vector sum
proc vsum(var r[n], val a[n], val b[n], val n) is
  var i;
{ for i:=1 to n do r[i] := a[i] + b[i]
}

% Slice and sum subsections of an array from reference
proc foo(var a[n], val n) is
  var r;
  var i;
{ for i:=0 to N-1 do a[i] := i

% Sum the beginning
; r := sum(a[0:n/3], n/3)
; printvalln(r)

% Sum the middle
; r := sum(a[n/3:2*(n/3)], n/3)
; printvalln(r)

% Sum the end
; r := sum(a[2*(n/3):n], n/3)
; printvalln(r)

}

% Slicing and summing using alias variables from references
proc bar(var a[n], var r[n], val n) is
  var x[];
  var y[];
  var res;
  var i;
{ for i := 0 to n-1 do a[i] := i
; x aliases a[0:n/2]
; y aliases a[n/2:n]

% Sum x
; res := sum(x, n/2)
; printvalln(res)

% Sum y
; res := sum(y, n/2-1)
; printvalln(res)

% Sum x and y
; vsum(r, x, y, n/2-1)
; res := sum(r, n/2)
; printvalln(res)

}

% Non-aliased array reference
proc baz() is
  var a[N];
  var i;
{ for i := 0 to N-1 do a[i] := i
; printvalln(sum(a[1:N-1], N-2))
}

proc main() is
  var a[N];
  var b[N];
%{ foo(a, N)
 bar(a, b, N)
%; baz()
%}

