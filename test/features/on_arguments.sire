val N := NUM_CORES-1;
val VAL := 0xDEADBEEF;
val X := 4;
val Y := 20;
val Z := 100;

proc p0(var r, val a, val b, val c, val d, var e[n], val n) is
  var i;
{ r := a and b and c and d
; for i in [0 for n] do r := r and e[i]
}

proc p1(var r, val a, val b, val c, 
    val d[n], val n, val e[m], val m) is
  var i;
{ r := a and b and c
; for i in [0 for n] do r := r and d[i]
; for i in [0 for m] do r := r and e[i]
}

proc p2(var r, val w[a], val x[b], val y[c], val z[d],
    val a, val b, val c, val d) is
  var i;
{ r := w[0]
; for i in [1 for a-1] do r := r and w[i]
; for i in [0 for b] do r := r and x[i]
; for i in [0 for c] do r := r and y[i]
; for i in [0 for d] do r := r and z[i]
}

proc main() is
  var i;
  var r;
  var v0;
  var v1;
  var v2;
  var v3;
  var v4;
  var v5;
  var v6;
  var v7;
  var v8;
  var a[X];
  var b[Y];
  var c[Z];
{
  v0 := VAL; 
  v1 := VAL; 
  v2 := VAL; 
  v3 := VAL; 
  v4 := VAL; 
  v5 := VAL; 
  v6 := VAL; 
  v7 := VAL; 
  v8 := VAL; 

  % NOTE restriction: system/definitions: MAX_PROC_ARGS = 10

  % 10 referenced variable parameters
  on N do r := v0 and v1 and v2 and v3 and v4 and v5 and v6 and v7 and v8;
  assert r = VAL;

  % One array onto the stack (from the stack)
  for i in [0 for X] do a[i] := VAL;
  on N do p0(r, VAL, VAL, VAL, VAL, a, X);
  assert r = VAL;

  % Two arrays onto the stack
  for i in [0 for X] do a[i] := VAL;
  for i in [0 for Y] do b[i] := VAL;
  on N do p1(r, VAL, VAL, VAL, a, X, b, Y);
  assert r = VAL;

  % Four arrays onto the stack
  for i in [0 for Y] do b[i] := VAL;
  for i in [0 for Z] do c[i] := VAL;
  on N do p2(r, a, b, b, c, X, Y, Y, Z);
  assert r = VAL
}

