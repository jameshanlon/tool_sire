val N := 2;

proc foo(val a, val b, val c, val d, val e, val f, val g, var r) is
  r := a+b+c+d+e+f+g

proc bar(val a, val b, val c, val d, var e[n], val n, var r) is
  var i;
{ r := a+b+c+d
; for i:=0 to n-1 do r := r + e[i]
}

proc baz(val a, val b, val c, var r, 
    val e[n], val n, val f[m], val m) is
  var i;
{ r := a+b+c
; for i:=0 to n-1 do r := r + e[i]
; for i:=0 to m-1 do r := r + f[i]
}

proc cat(val w[a], val x[b], val y[c], val z[d],
    val a, val b, val c, val d) is
  var i;
  var r;
{ r := 0
; for i:=0 to a-1 do r := r + w[i]
; for i:=0 to b-1 do r := r + x[i]
; for i:=0 to c-1 do r := r + y[i]
; for i:=0 to d-1 do r := r + z[i]
}

proc main() is
  var i;
  var r;
  var a[N];
  var b[2*N];
  var c[3*N];
  var d[4*N];
{ 
  % All 8 arguments with a referenced var
  on core[NUM_CORES-1] do foo(1, 2, 3, 4, 5, 6, 7, r)
; printvalln(r)

  % An array onto the stack with a referenced var
; for i:=0 to N-1 do a[i] := 5+i
; on core[NUM_CORES-1] do bar(1, 2, 3, 4, a, N, r)
; printvalln(r)

 % Two arrays onto the stack
; for i:=0 to N-1 do 
    a[i] := 4+i
; for i:=0 to (2*N)-1 do 
    b[i] := a[N-1]+i
; on core[NUM_CORES-1] do baz(1, 2, 3, r, a, N, b, 2*N)
; printvalln(r)

 % Four arrays onto the stack
; for i:=0 to (3*N)-1 do 
    c[i] := i 
; for i:=0 to (4*N)-1 do 
    d[i] := i 
; on core[NUM_CORES-1] do cat(a, b, c, d, N, N*2, N*3, N*4)
}

