val N:=2;

proc foo(val i, val j, chanend lf, chanend rt, chanend up, chanend dn) is 
  var u;
  var v;
{ if i = 0 and j = 0
  then
  { rt ! 1;
    dn ! 1;
    lf ? u;
    up ? v;
    assert u = N;
    assert v = N
  }
  else if i = 0
  then
  { rt ! 1;
    up ? u;
    dn ! u + 1;
    lf ? v;
    assert v = N
  }
  else if j = 0
  then
  { dn ! 1;
    lf ? u;
    rt ! u + 1;
    up ? v;
    assert v = N
  }
  else
  { lf ? u;
    up ? v;
    dn ! v + 1;
    rt ! u + 1
  }
}

proc main() is
  chan x[N*N];
  chan y[N*N];
  var i;
  var j;
  par i in [0 for N], j in [0 for N] do 
    foo(i, j, x[(i*N)+j], x[(i*N)+((j+1) rem N)],
              y[(j*N)+i], y[(j*N)+((i+1) rem N)])

