val N := 1;
val M := 1;

proc src_sink_ns(chanend input, chanend output) is
  var v;
{ input ! 0;
  output ? v;
  assert v = N
}

proc src_sink_we(chanend input, chanend output) is
  var v;
{ input ! 0;
  output ? v;
  assert v = M
}

proc cell(chanend n, chanend s, chanend w, chanend e) is
  var nin;
  var win;
{ n ? nin;
  w ? win;
  s ! nin + 1;
  e ! win + 1
}

proc main() is
  chan y[N*(N+1)];
  chan x[N*(N+1)];
  var i;
  var j;
{ par i in [0 for N] do src_sink_ns(y[i*M], y[(i*M)+N]) ||
  par i in [0 for N] do src_sink_ew(x[i*M], x[(i*M)+N]) ||
  par i in [0 for N], j in [0 for N] do
    cell(y[(i*M)+j], y[(i*M)+j+1],
         x[(j*M)+i], x[(j*M)+i+1]) 
}

