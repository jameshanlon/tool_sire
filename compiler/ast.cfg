#-----------------------------------------------------------------
# Each entry is a Node sub-class name, listing the attributes
# and child nodes of the class:
#   <name>*     - a child node
#   <name>**    - a sequence of child nodes
#   <name>      - an attribute
#-----------------------------------------------------------------

# Program
Program:        [decls*, defs*]

# Variable declarations
Decls:          [decl**]
DeclSingle:     [name, type, expr*] # Type(var, single)
DeclArray:      [name, type, expr*] # Type(var, array)
DeclVal:        [name, type, expr*] # Type(val, single)
DeclPort:       [name, type, expr*] # Type(port, single)

# Procedure declarations
Defs:           [decl**]
DefProc:        [name, type, formals*, vardecls*, stmt*]
DefFunc:        [name, type, formals*, vardecls*, stmt*]

# Formal parameters
Formals:        [params**]
ParamSingle:    [name, type] # Type(var, single)
ParamAlias:     [name, type] # Type(var, alias)
ParamVal:       [name, type] # Type(val, single)
ParamChanend:   [name, type] # Type(chanend, single)

# Statements
StmtSeq:        [stmt**]
StmtPar:        [stmt**]
StmtSkip:       []
StmtPcall:      [name, args*]
StmtAss:        [left*, expr*]
StmtIn:         [left*, expr*]
StmtOut:        [left*, expr*]
StmtIf:         [cond*, thenstmt*, elsestmt*]
StmtWhile:      [cond*, stmt*]
StmtFor:        [var*, init*, bound*, stmt*]
StmtOn:         [core*, pcall*]
StmtConnect:    [left*, core*, dest*]
StmtAliases:    [left*, name, expr*]
StmtReturn:     [expr*]

# Expressions
ExprList:       [expr**]
ExprSingle:     [elem*]
ExprUnary:      [op, elem*]
ExprBinop:      [op, elem*, right*]

# Elements
ElemGroup:      [expr*]
ElemSub:        [name, expr*]
ElemFcall:      [name, args*]
ElemNumber:     [value]
ElemBoolean:    [value]
ElemString:     [value]
ElemChar:       [value]
ElemId:         [name]
