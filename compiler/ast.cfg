#-----------------------------------------------------------------
# Each entry is a Node sub-class name, listing the attributes
# and child nodes of the class:
#   <name>*     - a child node
#   <name>**    - a sequence of child nodes
#   <name>      - an attribute
#-----------------------------------------------------------------

# Program
Program:      [decls*, defs*]

# Variable declarations
Decls:        [decl**]
DeclSingle:   [name*, type, form, expr*]
DeclArray:    [name*, type, form, expr*]
DeclVal:      [name*, type, form, expr*]
DeclPort:     [name*, type, form, expr*]

# Procedure declarations
Defs:         [decl**]
DefProc:      [name*, formals*, vardecls*, stmt*]
DefFunc:      [name*, formals*, vardecls*, stmt*]

# Formal parameters
Formals:      [params**]
ParamVar:     [name, type, form]
ParamAlias:   [name, type, form]
ParamVal:     [name, type, form]
ParamChanend: [name, type, form]

# Statements
StmtSeq:      [stmt**]
StmtPar:      [stmt**]
StmtSkip:     []
StmtPcall:    [name*, args*]
StmtAss:      [left*, expr*]
StmtIn:       [left*, expr*]
StmtOut:      [left*, expr*]
StmtIf:       [cond*, thenstmt*, elsestmt*]
StmtWhile:    [cond*, stmt*]
StmtFor:      [var*, init*, bound*, stmt*]
StmtOn:       [core*, pcall*]
StmtConnect:  [left*, core*, dest*]
StmtAliases:  [left*, name*, expr*]
StmtReturn:   [expr*]

# Expressions
ExprList:     [expr**]
ExprSingle:   [elem*]
ExprUnary:    [op, elem*]
ExprBinop:    [op, elem*, right*]

# Elements
ElemGroup:    [expr*]
ElemSub:      [name*, expr*]
ElemFcall:    [name*, args*]
ElemNumber:   [value]
ElemBoolean:  [value]
ElemString:   [value]
ElemChar:     [value]
ElemId:       [value]
